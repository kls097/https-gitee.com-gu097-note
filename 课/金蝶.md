- [1、插件开发](#1-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91)
- [2、动态表单](#2-%E5%8A%A8%E6%80%81%E8%A1%A8%E5%8D%95)

# 1、插件开发

前端控件名字是标识，需要注册插件，插件路径是插件的全类名，插件类要添加监听，动态表单要在初始化方法里面，单据则要在addXXXListener方法里面。

# 2、动态表单

1. beforeClick与Click：按钮的点击操作会触发
   before可以取消Click方法执行，使用evt.cancle(true)即可。
   可以使用evt.getKey(String key)获取正在操作的控件标识，从而精确控制控件。

2. itemClick与beforeItemClick：菜单按钮的点击操作，类似于Click

3. beforeDoOperation
   触发时机:用户点击按钮、菜单，执行绑定的操作逻辑前，触发此事件；
   需要控件的操作代码绑定操作才可以。下面绑定了一个叫做option的操作。
   插件可以在此事件：
   
   1. 提示确认消息；this.getView().showXXX()
   2. 校验数据，取消操作的执行； e.setCancle(true)
   3. 传递给自定义操作参数给操作服务、操作插件；
   
   ```java
   formOperate.getOption().setVariableValue("key","value");
   @Override
       public void beforeDoOperation(BeforeDoOperationEventArgs args) {
           super.beforeDoOperation(args);
           FormOperate formOperate = (FormOperate) args.getSource();
           String key = formOperate.getOperateKey();
           if ("operation".equals(key)) {
               //给operation类传递数据
               formOperate.getOption().setVariableValue("key","value");
               //取消operation操作
               args.setCancel(true);
           }
   }
   ```

4. afterDoOperation
   触发时机:用户点击按钮、菜单，执行完绑定的操作后，不论成功与否，均会触发此事件；插件可以在此事件，根 据操作结果控制界面
   
   ```java
   public class AfterDoOperation extends AbstractFormPlugin {
       final static String KEY_OPKEY = "myoperation";
       @Override
       public void afterDoOperation(AfterDoOperationEventArgs args) {
           super.afterDoOperation(args);
           FormOperate formOperate = (FormOperate)args.getSource();
           if (StringUtils.equals(KEY_OPKEY, formOperate.getOperateKey())
           && args.getOperationResult() != null
           && args.getOperationResult().isSuccess()){
               // TODO 在此添加业务逻辑
           }
       }
   }
   ```

5. confirmCallBack
   
   触发时机：用户确认了交互提示信息后，触发此事件，通知插件进行后续处理；插件可以在此事件，了解用户的态 度，决定后续业务逻辑。

6. closedCallBack
   
   触发时机：子界面关闭时，触发父界面的closedCallBack事件；父界面的插件，可以在此事件，接收子界面返回的 数据。

7. propertyChanged
   
   触发时机：表单模型某个字段值改变的时候就会触发此事件。 注意：单据头文本字段，日期字段等基础字段需勾选即时触发值更新，基础资料字段，单据体字段不需要。

# 三、界面规则

```
就是对于某一个表单或者单据什么的，对其中一些字段进行逻辑或者数学等方面判断，返回一个布尔值，根据值确定做什么操作，例如隐藏字段、锁定字段等等 
```

# 四、编码规则

```
就是一种编码的生成规则配置，配置完成之后，可以生成唯一且易读的编码。 
```

# 五、应用规则

1. 不允许断号 ：新增单据时，编码自动生成不显示不允许编辑。编码作废之后，会触发断号回收服务。
2. 新增显示：新增单据时，编码字段自动显示 编码规则产生的编码，且不可编辑。
3. 新增显示且允许修改： 新单据时，编码字段自动显示编码规则产生的编码，且可以编 辑。
4. 修改时重新编码： 编码规则分段中的值发生变化后， 按编码规则重新生成编码。要实时显示效果还需打开编码字段的即时触发值更新属性。这时候，编码的某一部分往往来源于某一个会发生变化的字段。

# 六、插件开发上下文this.getXXX

1. Control：控件。Control类是所有控件的父类。this.getControl()，this.getControl(String key)
2. Model：数据模型，类似于map，通过它可以得到key-value数据。
3. View：界面模型

# 七、引入引出

```
从excel中读取数据为引入，将数据保存到excel中为引出。 
```

## 引入插件的相关事件：

1. InitImport：引入的数据解析完成生成一条条元数据，仅触发一次

```java
public void initImportData(InitImportDataEventArgs e) {
    //引入的单据数据集合
    //map里key为引入数据的属性标识，value为引入数据的属性值
    List<Map<String, Object>> sourceDataList = e.getSourceDataList();
}
```

2. BeforeImport：每一条元数据被引入前都会被触发，一张表格引入的数据如果有很多条，那么也就会触发很多次。插件可以对本次引入的源单数据包，进行修订；或者取消本单引入

```java
/**
- 如果单据不是暂存状态则不引入
*/
@Override
public void beforeImportData(BeforeImportDataEventArgs e) {
    Map<String, Object> sourceData = e.getSourceData();
    Object billstatus = sourceData.get("billstatus");
    if (null != billstatus && !"A".equals(billstatus)) {
        e.setCancel(true);
        e.setCancelMessage("当前单据状态为"+billstatus+",非暂存状态，不引入");
    }
}
```

3. AfterImport：类似于beforeImport，只不过是在引入后保存前触发。

```java
public void afterImportData(ImportDataEventArgs e) {
//获取单张单据的引入数据
Map<String, Object> sourceData = e.getSourceData();
}
```

**案例：**

```java
/**
- 如果单据不是暂存状态则不引入
*/
@Override
public void beforeImportData(BeforeImportDataEventArgs e) {
    Map<String, Object> sourceData = e.getSourceData();
    Object billstatus = sourceData.get("billstatus");
    if (null != billstatus && !"A".equals(billstatus)) {
        e.setCancel(true);
        e.setCancelMessage("当前单据状态为"+billstatus+",非暂存状态，不引入");
    }
}
```

# 八、数据库业务接口案例

1. 给Item上的按钮添加监听，需要对整个工具栏监听。addItemClickListeners("toolbarap");
2. //获取单据体集合时，参数是整个单据的标识
   DynamicObjectCollection entrys = bill.getDynamicObjectCollection("entryentity");
3. 列表控件叫做billlistap。this.getControl("billlistap");
4. XXXOprate()这样的api可以在完成各种操作的同时触发各种Opration插件

```java
//在其他业务里的代码，保存单据并传送数据  
OperateOption option = OperateOption.create();  
option.setVariableValue("test","testParam");  
SaveServiceHelper.saveOperate("test_0101", new DynamicObject[] {bill},option);  


//在Opration插件里面的代码，被触发并可以接收数据  
@Override  
public void beforeExecuteOperationTransaction(BeforeOperationArgs e) {  
    String key = e.getOperationKey();  
    System.out.println(key+"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");  
    if ("save".equals(key)) {  
        doAdd(e);  
    } else if ("delete".equals(key)) {  
        doDelete(e);  
    }  
}  
public void doAdd(BeforeOperationArgs e) {  
    Set<Map.Entry<String, String>> set = this.getOption().getVariables().entrySet();  
    for (Map.Entry<String, String> entry : set) {  
        System.out.print("key::" + entry.getKey());  
        System.out.println("::::::::::::::::::::::value::" + entry.getValue());  
    }  
    System.out.println("触发保存");  
}
```

5. 查询需要使用QueryServiceHelper.query(entrytyName, 需要查的参数，过滤器)，每一条查询结果都是平铺单据对象。也就是说如果一个单据有多个单据体，那么这一条单据会以多条查询结果返回，一个结果只会有一个单据体。
   平铺的对象是不可以通过SaveServiceHelp保存的。

```java
@SuppressWarnings("all")  
public class dataPluginDemo extends AbstractListPlugin {  

    @Override  
    public void registerListener(EventObject e) {  
        super.registerListener(e);  
        addItemClickListeners("toolbarap");  
    }  

    @Override  
    public void itemClick(ItemClickEvent evt) {  
        super.itemClick(evt);  
        String key = evt.getItemKey();  
        if ("addnew".equals(key)) {  
            DynamicObject bill = BusinessDataServiceHelper.newDynamicObject("test_0101");  
            bill.set("billno", System.currentTimeMillis());  
            bill.set("billstatus", "A");  
            bill.set("auditor", RequestContext.get().getOrgId());  
            bill.set("creator", RequestContext.get().getUserId());  

            //获取单据体集合  
             DynamicObjectCollection entrys = bill.getDynamicObjectCollection("entryentity");  
            //获取单据体的Type  
            DynamicObjectType type = entrys.getDynamicObjectType();  
            //根据Type创建单据体对象  
            DynamicObject entry  =  new DynamicObject(type);  
            //设置单据体属性  
            entry.set("pricefield", (int)(100*Math.random()));  
            entry.set("unitfield", "个");  
            entry.set("qtyfield", (int)(100*Math.random()));  
            BigDecimal price = entry.getBigDecimal("pricefield");  
            BigDecimal qty = entry.getBigDecimal("qtyfield");  
            int priceInt = price.toBigInteger().intValue();  
            int qtyInt = price.toBigInteger().intValue();  
            entry.set("amountfield",new BigDecimal(priceInt*qtyInt));  
            //添加到单据体集合  
            entrys.add(entry);  
            // 保存  
            SaveServiceHelper.saveOperate("test_0101", new DynamicObject[] {bill});  

            BillList list = this.getControl("billlistap");  
            list.refresh();  
        } else if ("getone".equals(key)) {  
            BillList list = this.getControl("billlistap");  
            Object[] pks = list.getSelectedRows().getPrimaryKeyValues();  
            System.out.println("test::::"+Arrays.toString(pks));  
            DynamicObject dyobj = BusinessDataServiceHelper.loadSingle(pks[0], "test_0101");  
            this.getView().showMessage(dyobj.toString());  
        } else if (!"mdelete".equals(key)) {  
            //获取list对象  
            BillList list = this.getControl("billlistap");  
            //获取选中的单据体的主键集合  
            Object[] pks = list.getSelectedRows().getPrimaryKeyValues();  

            //判断能否删除，如果状态为暂存则可以删除  
            for (int i = 0; i < pks.length; i++) {  
                DynamicObject dyobj = BusinessDataServiceHelper.loadSingle(pks[i], "test_0101");  
                if ("A".equals(dyobj.get("billstatus"))) {  
                    this.getView().showMessage("只能删除暂存状态的数据！选中数据中包含非暂存数据。");  
                    return;  
                }  
            }  

            //删除选中的单据体数据，需要制定Type  
            DeleteServiceHelper.delete(list.getEntityType(), pks);  

            //利用这个api删除会触发插件,并且有返回结果告知操作是否成功
            // DeleteServiceHelper helper = new DeleteServiceHelper();
            //OperationResult result = helper.deleteOperate("test_0101", pks, OperateOption.create());
            //System.out.println("操作结果："+result.toString()+result.getMessage());

            //刷新  
            list.refresh();  
        }else if ("query".equals(key)) {  
            //获取列表控件  
            BillList list = this.getControl("billlistap");  
            //获取被选中行集合对象  
            ListSelectedRowCollection selectedRows = list.getSelectedRows();  
            //如果没有选中，直接结束  
            if (selectedRows.size() <= 0) return;  

            //拼接查询条件，填入n个?，以及生成参数列表list1，其中存储着所有选中行的单据号billno  
            List<Object> list1 = new ArrayList<>();  
            String s = "fbillno in (";  
            for (int i = 0; i < selectedRows.size()-1; i++) {  
                list1.add(selectedRows.get(i).getBillNo());  
                s += "?,";  
            }  
            list1.add(selectedRows.get(selectedRows.size()-1).getBillNo());  
            s += "?)";  

            //创建过滤器,如果需要使用通配符，需要使用new方式创建  
            //QFilter filter = QFilter.of("billno =?", "12345");  
            //QFilter filter1 = filter.or(new QFilter("billno", QCP.in, list1));  

            //查询，返回单据集合  
            DynamicObjectCollection cols = QueryServiceHelper.query("test_0101", "id,billno,entryentity.pricefield price", new QFilter("billno", QCP.in, list1).toArray());  

            //输出第一个单据对象的单据体中的价格  
            this.getView().showMessage(cols.get(0).getString("price"));  
        }  
    }  
}
```

# 九、业务规则

类似于界面规则，就是满足条件或者不满足条件后会执行什么，只不过这里执行的不是字段的显示或锁定，而是字段值的一些简单计算在显示。



# 十、多布局

就是一个界面，继承或者说依赖于一个已经完成的表单，对父表单的界面进行修改，隐藏一些字段等。



# 十一、云与应用设计

## 什么是云

云---应用----各个功能单据基础资料等

就像财务云一样，应付应收都是它下面的应用。

1. 定义：一个完整的业务领域解决方案

2. 一个业务云客包括多个应用

3. 一个业务云与其他业务云可有业务相关性

4. <font color="red">通常一个业务云的数据存放在同一个数据库中，也支持将几个业务云数据存放在同一数据库中。</font>
   
   ![](E:\097\note\img\kdimg\2021-12-22-15-37-28-image.png)

## 行业特性

不同的云可能用于不同的行业，在创建云的时候需要填写，以确定开发的功能方向。

1. 如果“云”是通用类业务，“行业”属性不填写

2. 如果“云”是行业特性的，“行业”属性选择对应行业

3. 通常只有发布行业产品时才需要设置此属性，客户个性化开发无需设置此属性。

## 什么是应用

1. 定义：一个可独立使用的业务、或者是一组具有相同意义的功能

2. 企业应用迭代时，可以选择一个业务云中的不同应用进行实施、升级和迭代

3. **微服务的最小粒度是应用（高内聚、低耦合）**

4. <font color="red">应用划分应尽量避免跨应用的写操作</font>

5. 应用是整个业务云进行分类管理的根本(页面、功能)
   
   ![](E:\097\note\img\kdimg\2021-12-22-15-52-59-image.png)
   
   <img src="file:///E:/097/note/img/kdimg/2021-12-22-15-54-30-image.png" title="" alt="" width="683">

## 应用的属性

### 适用用户

1. 应用区分用户类型

2. 系统在框架层做功能<mark>访问权限过滤</mark>



### 首页配置

![](E:\097\note\img\kdimg\2021-12-22-15-56-22-image.png)

1. 每个应用都有属于本应用独有的首页;

2. 每个应用在新建时自动生成默认应用首页;

3. 在应用中可以自定义首页，然后配置到应用的首页属性中;

4. 首页包含“菜单”，各种卡片，在运行期用户可以自定义配置



### 基础应用

![](E:\097\note\img\kdimg\2021-12-22-15-58-30-image.png)

基础应用设计规则∶

1. 单个”应用“共用的基础资料，定义在”应用“中

2. 同一“云”中共用基础资料，在“云”中设计类似基础资料应用

3. 多个“云”共用基础资料，在“系统云”中设计基础资料应用